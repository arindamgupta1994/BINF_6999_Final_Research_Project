source("D:/University/M.Bioinformatics/Semester 3/RStudio/Project_Trial_1/Scrip1.R")
for (i in seq_along(k_list)) {
k <- k_list[i]
print(paste("Fitting NMF with k =", k))
fit <- nmf(final_nmf_matrix,
rank = k,
nrun = 10,
.options = "N")
rss_list[i] <- residuals(fit)
}
best_k <- uik(k_list, rss_list, plot = TRUE)$iplast
install.packages("NMF", "inflection")
best_k <- uik(k_list, rss_list, plot = TRUE)$iplast
install.packages("inflection", dependencies = TRUE)
best_k <- uik(k_list, rss_list, plot = TRUE)$iplast
#library(NMF)        # for nmf()
#library(caret)      # for train/test split + RMSE
library(inflection) # for uik()
best_k <- uik(k_list, rss_list, plot = TRUE)$iplast
knee    <- uik(rank_list, rss_list)   # CRAN version has no plot arg
knee    <- uik(k_list, rss_list)   # CRAN version has no plot arg
best_k  <- knee$iplast
best_k  <- knee[1]
knee    <- uik(k_list, rss_list)   # CRAN version has no plot arg
best_k  <- knee[1]
# optional manual plot
plot(k_list, rss_list, type = "b")
abline(v = best_k, col = "red", lty = 2)
cat("UIK suggests k = ", best_k, "\n")
set.seed(2025)
nmf_final <- nmf(final_nmf_matrix,
k = best_k,
nrun = 50,
.options = "p")
nmf_final <- nmf(final_nmf_matrix,
rank = best_k,
nrun = 50,
.options = "p")
w <- coef(nmf_final)
colnames(w) <- paste0("Factor", seq_len(best_k))
View(w)
w <- basis(nmf_final)
colnames(w) <- paste0("Factor", seq_len(ncol(w)))
View(w)
df_nmf <- data.frame(
Yield = nmf_matrix$Yield,
soilRank = nmf_matrix$SoilRank,
w
)
lm_nmf <- lm(formula = paste("Yield ~ soilRank +", paste(colnames(w), collapse = " + ")),
data = df_nmf
)
df_nmf <- data.frame(
Yield = nmf_matrix$Yield,
soilRank = nmf_matrix$SoilRank,
w
)
lm_nmf <- lm(formula = paste("Yield ~ soilRank +", paste(colnames(w), collapse = " + ")),
data = df_nmf
)
lm_env <- lm(formula = paste("Yield ~", paste(env_cols, collapse = " + ")), data = nmf_matrix)
nmf_matrix$EI <- predict(lm_env, newdata = nmf_matrix)
lm_EI <- lm(Yield ~ EI*Variety.Name, data = nmf_matrix)
install.packages("NMF", "inflection", "caret", dependencies = TRUE)
library(NMF)        # for nmf()
library(caret)      # for train/test split + RMSE
library(inflection) # for uik()
set.seed(2025)
train <- createDataPartition(nmf_matrix$Yield, p = 0.8, list = FALSE)
View(train)
?`predict,NMF-method`
############################################################################
# 1.  LOAD DATA
############################################################################
data <- as.data.frame(read.delim("./Data/OSACC Data Registered Varieties 1996-2021 with variety names.txt", header = T))
# Check names of columns
colnames(new_df)
# Check all of the soil types that exists in the dataset
unique(new_df$Soil.Type)
############################################################################
# 1.  LOAD DATA
############################################################################
new_df <- as.data.frame(read.delim("./Data/OSACC Data Registered Varieties 1996-2021 with variety names.txt", header = T))
# Check names of columns
colnames(new_df)
# Check all of the soil types that exists in the dataset
unique(new_df$Soil.Type)
# Lower case and trim white spaces of soil types
new_df$Soil.Type <- tolower(trimws(new_df$Soil.Type))
# Check cleaned up soil types
unique(new_df$Soil.Type)
# Create Soil Rank
soil_Rank <- c(
"loam"      = 1.0,
"silt loam" = 0.8,
"clay loam" = 0.6,
"clay"      = 0.4,
"sand"      = 0.2
)
# Add the soil rank column to the df
new_df$SoilRank <- soil_Rank[new_df$Soil.Type]
# Impute with median of soil ranks listed above
median_soil <- median(soil_Rank)
new_df$SoilRank[is.na(new_df$SoilRank)] <- median_soil
# Check if all NA values were assigned a number
sum(is.na(new_df$SoilRank))
# Create a list with names of the features
env_cols <- c("SoilRank", "HUZ", "DTM",
"Lodging", "Height", "SeedWt",
"Protein", "Oil")
# Create a new data frame to store the scaled matrix
scaled_df <- new_df
# Scale the matrix using min-max normalization
for (cols in env_cols) {
min_val <- min(scaled_df[[cols]], na.rm = T)
max_val <- max(scaled_df[[cols]], na.rm = T)
scaled_df[[cols]] <- (scaled_df[[cols]] - min_val)/(max_val - min_val)
}
# Remove soilRank from matrix
env_no_soil <- setdiff(env_cols, "SoilRank")
# rows before dropping NA values
rows_before <- nrow(scaled_df)
# Keep rows that have no NA values in any column
keep_rows <- complete.cases(scaled_df[, env_no_soil])
nmf_matrix_clean <- scaled_df[keep_rows, ]
# Check the number of rows after cleaning
rows_after <- nrow(nmf_matrix_clean)
cat("Dropped", rows_before - rows_after,
"rows with NA in", paste(env_no_soil, collapse = ", "), "\n")
############################################################################
# 5.  FILTER 2:  DROP LOCATIONS WITH < 6 REMAINING ROWS
############################################################################
loc_counts <- table(nmf_matrix_clean$Location)
keep_locations <- names(loc_counts[loc_counts>= 6])
nmf_matrix <- nmf_matrix_clean[nmf_matrix_clean$Location %in% keep_locations, ]
rows_after_loc <- nrow(nmf_matrix)
cat("Dropped", rows_after - rows_after_loc,
"rows from Locations with < 6 rows;",
"Final rows left:", rows_after_loc, "\n")
# Double check if there are any NA values in nmf matrix
anyNA(nmf_matrix)
set.seed(2025)
train <- createDataPartition(nmf_matrix$Yield, p = 0.8, list = FALSE)
train_df <- nmf_matrix[train, ]
test_df <- nmf_matrix[-train, ]
# NMF input matrices (7 features, no SoilIdx)
X_train <- as.matrix(train_df[, env_no_soil])
X_test  <- as.matrix(test_df [, env_no_soil])
# create list of k values to find ideal value
k_list <- 2:7
rss_list <- numeric(length(k_list))
set.seed(2025)
for (i in seq_along(k_list)) {
k <- k_list[i]
print(paste("Fitting NMF with k =", k))
fit <- nmf(X_train,
rank = k,
nrun = 10,
.options = "N")
rss_list[i] <- residuals(fit)
}
best_k <- uik(k_list, rss_list)[1]
# Plot of the inflection point
plot(k_list, rss_list, type = "b")
abline(v = best_k, col = "red", lty = 2)
cat("UIK suggests k = ", best_k, "\n")
set.seed(2025)
nmf_final <- nmf(X_train,
rank = best_k,
nrun = 50,
.options = "p")
w_train <- basis(nmf_final)
colnames(w_train) <- paste0("Factor", seq_len(ncol(w_train)))
# Project Test rows into same factors (what = "basis" means returning the w matrix scores. w matrix is the basis matrix)
w_test <- predict(nmf_final, newdata = X_test, what = "basis")
# Project Test rows into same factors (what = "basis" means returning the w matrix scores. w matrix is the basis matrix)
w_test <- predict(nmf_final, newdata = X_test, what = "samples")
w_train <- basis(nmf_final)
colnames(w_train) <- paste0("Factor", seq_len(ncol(w_train)))
# Project Test rows into same factors (what = "basis" means returning the w matrix scores. w matrix is the basis matrix)
w_test <- predict(nmf_final, newdata = X_test, what = "samples")
# Project Test rows into same factors
w_test <- predict(nmf_final, X_test, what = "samples")
# Project Test rows into same factors
w_test <- predict(nmf_final, newdata = X_test, what = "columns")
install.packages("remotes")
source("D:/University/M.Bioinformatics/Semester 3/RStudio/Project_Trial_1/Scrip1.R")
install.packages("remotes")
install.packages("NMF", "inflection", "caret", dependencies = TRUE)
library(NMF)        # for nmf()
library(caret)      # for train/test split + RMSE
library(inflection) # for uik()
library(NMF)        # for nmf()
install.packages("remotes")
remotes::install_github("renozao/NMF")
############################################################################
# 1.  LOAD DATA
############################################################################
new_df <- as.data.frame(read.delim("./Data/OSACC Data Registered Varieties 1996-2021 with variety names.txt", header = T))
# Check names of columns
colnames(new_df)
# Check all of the soil types that exists in the dataset
unique(new_df$Soil.Type)
# Lower case and trim white spaces of soil types
new_df$Soil.Type <- tolower(trimws(new_df$Soil.Type))
# Check cleaned up soil types
unique(new_df$Soil.Type)
# Create Soil Rank
soil_Rank <- c(
"loam"      = 1.0,
"silt loam" = 0.8,
"clay loam" = 0.6,
"clay"      = 0.4,
"sand"      = 0.2
)
# Add the soil rank column to the df
new_df$SoilRank <- soil_Rank[new_df$Soil.Type]
# Impute with median of soil ranks listed above
median_soil <- median(soil_Rank)
new_df$SoilRank[is.na(new_df$SoilRank)] <- median_soil
# Check if all NA values were assigned a number
sum(is.na(new_df$SoilRank))
# Create a list with names of the features
env_cols <- c("SoilRank", "HUZ", "DTM",
"Lodging", "Height", "SeedWt",
"Protein", "Oil")
# Create a new data frame to store the scaled matrix
scaled_df <- new_df
# Scale the matrix using min-max normalization
for (cols in env_cols) {
min_val <- min(scaled_df[[cols]], na.rm = T)
max_val <- max(scaled_df[[cols]], na.rm = T)
scaled_df[[cols]] <- (scaled_df[[cols]] - min_val)/(max_val - min_val)
}
# Remove soilRank from matrix
env_no_soil <- setdiff(env_cols, "SoilRank")
# rows before dropping NA values
rows_before <- nrow(scaled_df)
# Keep rows that have no NA values in any column
keep_rows <- complete.cases(scaled_df[, env_no_soil])
nmf_matrix_clean <- scaled_df[keep_rows, ]
# Check the number of rows after cleaning
rows_after <- nrow(nmf_matrix_clean)
cat("Dropped", rows_before - rows_after,
"rows with NA in", paste(env_no_soil, collapse = ", "), "\n")
############################################################################
# 5.  FILTER 2:  DROP LOCATIONS WITH < 6 REMAINING ROWS
############################################################################
loc_counts <- table(nmf_matrix_clean$Location)
keep_locations <- names(loc_counts[loc_counts>= 6])
nmf_matrix <- nmf_matrix_clean[nmf_matrix_clean$Location %in% keep_locations, ]
rows_after_loc <- nrow(nmf_matrix)
cat("Dropped", rows_after - rows_after_loc,
"rows from Locations with < 6 rows;",
"Final rows left:", rows_after_loc, "\n")
# Double check if there are any NA values in nmf matrix
anyNA(nmf_matrix)
set.seed(2025)
train <- createDataPartition(nmf_matrix$Yield, p = 0.8, list = FALSE)
train_df <- nmf_matrix[train, ]
test_df <- nmf_matrix[-train, ]
library(NMF)        # for nmf()
library(caret)      # for train/test split + RMSE
library(inflection) # for uik()
set.seed(2025)
train <- createDataPartition(nmf_matrix$Yield, p = 0.8, list = FALSE)
train_df <- nmf_matrix[train, ]
test_df <- nmf_matrix[-train, ]
# NMF input matrices (7 features, no SoilIdx)
X_train <- as.matrix(train_df[, env_no_soil])
X_test  <- as.matrix(test_df [, env_no_soil])
# create list of k values to find ideal value
k_list <- 2:7
rss_list <- numeric(length(k_list))
set.seed(2025)
for (i in seq_along(k_list)) {
k <- k_list[i]
print(paste("Fitting NMF with k =", k))
fit <- nmf(X_train,
rank = k,
nrun = 10,
.options = "N")
rss_list[i] <- residuals(fit)
}
best_k <- uik(k_list, rss_list)[1]
# Plot of the inflection point
plot(k_list, rss_list, type = "b")
abline(v = best_k, col = "red", lty = 2)
cat("UIK suggests k = ", best_k, "\n")
set.seed(2025)
nmf_final <- nmf(X_train,
rank = best_k,
nrun = 50,
.options = "p")
w_train <- basis(nmf_final)
colnames(w_train) <- paste0("Factor", seq_len(ncol(w_train)))
# Project Test rows into same factors
w_test <- predict(nmf_final, newdata = X_test, what = "basis")
# Project Test rows into same factors
w_test <- predict(nmf_final, newdata = X_test, what = "columns")
# Project Test rows into same factors
w_test <- predict(nmf_final, X_test, what = "columns")
# Project Test rows into same factors
w_test <- predict(nmf_final, X_test, what = "columns", dmatrix = FALSE)
h_train <- t(coeff(nmf_final))
h_train <- t(coef(nmf_final))
colnames(h_train) <- paste0("Factor", seq_len(ncol(h_train)))
# Project Test rows into same factors
h_test <- t(predict(nmf_final, X_test, what = "coef"))
train_df <- nmf_matrix[train, ]
test_df <- nmf_matrix[-train, ]
# NMF input matrices (7 features, no SoilRank), rows = features, cols = samples
X_train <- t(as.matrix(train_df[, env_no_soil]))
X_test  <- t(as.matrix(test_df [, env_no_soil]))
# create list of k values to find ideal value
k_list <- 2:7
rss_list <- numeric(length(k_list))
set.seed(2025)
for (i in seq_along(k_list)) {
k <- k_list[i]
print(paste("Fitting NMF with k =", k))
fit <- nmf(X_train,
rank = k,
nrun = 10,
.options = "N")
rss_list[i] <- residuals(fit)
}
source("D:/University/M.Bioinformatics/Semester 3/RStudio/Project_Trial_1/Scrip1.R")
############################################################################
# 1.  LOAD DATA
############################################################################
new_df <- as.data.frame(read.delim("./Data/OSACC Data Registered Varieties 1996-2021 with variety names.txt", header = T))
# Check names of columns
colnames(new_df)
# Check all of the soil types that exists in the dataset
unique(new_df$Soil.Type)
# Lower case and trim white spaces of soil types
new_df$Soil.Type <- tolower(trimws(new_df$Soil.Type))
# Check cleaned up soil types
unique(new_df$Soil.Type)
# Create Soil Rank
soil_Rank <- c(
"loam"      = 1.0,
"silt loam" = 0.8,
"clay loam" = 0.6,
"clay"      = 0.4,
"sand"      = 0.2
)
# Add the soil rank column to the df
new_df$SoilRank <- soil_Rank[new_df$Soil.Type]
# Impute with median of soil ranks listed above
median_soil <- median(soil_Rank)
new_df$SoilRank[is.na(new_df$SoilRank)] <- median_soil
# Check if all NA values were assigned a number
sum(is.na(new_df$SoilRank))
# Create a list with names of the features
env_cols <- c("SoilRank", "HUZ", "DTM",
"Lodging", "Height", "SeedWt",
"Protein", "Oil")
# Create a new data frame to store the scaled matrix
scaled_df <- new_df
# Scale the matrix using min-max normalization
for (cols in env_cols) {
min_val <- min(scaled_df[[cols]], na.rm = T)
max_val <- max(scaled_df[[cols]], na.rm = T)
scaled_df[[cols]] <- (scaled_df[[cols]] - min_val)/(max_val - min_val)
}
# Remove soilRank from matrix
env_no_soil <- setdiff(env_cols, "SoilRank")
# rows before dropping NA values
rows_before <- nrow(scaled_df)
# Keep rows that have no NA values in any column
keep_rows <- complete.cases(scaled_df[, env_no_soil])
nmf_matrix_clean <- scaled_df[keep_rows, ]
# Check the number of rows after cleaning
rows_after <- nrow(nmf_matrix_clean)
cat("Dropped", rows_before - rows_after,
"rows with NA in", paste(env_no_soil, collapse = ", "), "\n")
############################################################################
# 5.  FILTER 2:  DROP LOCATIONS WITH < 6 REMAINING ROWS
############################################################################
loc_counts <- table(nmf_matrix_clean$Location)
keep_locations <- names(loc_counts[loc_counts>= 6])
nmf_matrix <- nmf_matrix_clean[nmf_matrix_clean$Location %in% keep_locations, ]
rows_after_loc <- nrow(nmf_matrix)
cat("Dropped", rows_after - rows_after_loc,
"rows from Locations with < 6 rows;",
"Final rows left:", rows_after_loc, "\n")
# Double check if there are any NA values in nmf matrix
anyNA(nmf_matrix)
set.seed(2025)
train <- createDataPartition(nmf_matrix$Yield, p = 0.8, list = FALSE)
train_df <- nmf_matrix[train, ]
test_df <- nmf_matrix[-train, ]
# NMF input matrices (7 features, no SoilRank), rows = features, cols = samples
X_train <- as.matrix(train_df[, env_no_soil])
install.packages("NMF", "inflection", "caret", dependencies = TRUE)
sessionInfo()
install.packages("installr")
library(installr) # for uik()
updateR()
updateR()
updateR()
source("D:/University/M.Bioinformatics/Semester 3/RStudio/Project_Trial_1/Scrip1.R")
updateR()
install.packages("installr")
updateR()
library(installr) # for uik()
updateR()
install.packages("NMF", "inflection", "caret")
install.packages("remote")
install.packages("remotes")
remotes::install_github("renozao/NMF")
library(NMF)        # for nmf()
install.packages("NMF")
library(NMF)        # for nmf()
install.packages("NMF", dependencies = TRUE)
library(NMF)        # for nmf()
install.packages("Biobase")
library(NMF)        # for nmf()
install.packages("BiocManager")
BiocManager::install("Biobase")
install.packages("NMF", "caret", "inflection")
library(NMF)        # for nmf()
library(caret)      # for train/test split + RMSE
library(inflection) # for uik()
install.packages("inflection")
library(inflection) # for uik()
install.packages("caret")
library(caret)      # for train/test split + RMSE
############################################################################
# 1.  LOAD DATA
############################################################################
new_df <- as.data.frame(read.delim("./Data/OSACC Data Registered Varieties 1996-2021 with variety names.txt", header = T))
# Check names of columns
colnames(new_df)
# Check all of the soil types that exists in the dataset
unique(new_df$Soil.Type)
# Lower case and trim white spaces of soil types
new_df$Soil.Type <- tolower(trimws(new_df$Soil.Type))
# Check cleaned up soil types
unique(new_df$Soil.Type)
# Create Soil Rank
soil_Rank <- c(
"loam"      = 1.0,
"silt loam" = 0.8,
"clay loam" = 0.6,
"clay"      = 0.4,
"sand"      = 0.2
)
# Add the soil rank column to the df
new_df$SoilRank <- soil_Rank[new_df$Soil.Type]
# Impute with median of soil ranks listed above
median_soil <- median(soil_Rank)
new_df$SoilRank[is.na(new_df$SoilRank)] <- median_soil
# Check if all NA values were assigned a number
sum(is.na(new_df$SoilRank))
# Create a list with names of the features
env_cols <- c("SoilRank", "HUZ", "DTM",
"Lodging", "Height", "SeedWt",
"Protein", "Oil")
# Create a new data frame to store the scaled matrix
scaled_df <- new_df
# Scale the matrix using min-max normalization
for (cols in env_cols) {
min_val <- min(scaled_df[[cols]], na.rm = T)
max_val <- max(scaled_df[[cols]], na.rm = T)
scaled_df[[cols]] <- (scaled_df[[cols]] - min_val)/(max_val - min_val)
}
# Remove soilRank from matrix
env_no_soil <- setdiff(env_cols, "SoilRank")
# rows before dropping NA values
rows_before <- nrow(scaled_df)
# Keep rows that have no NA values in any column
keep_rows <- complete.cases(scaled_df[, env_no_soil])
nmf_matrix_clean <- scaled_df[keep_rows, ]
# Check the number of rows after cleaning
rows_after <- nrow(nmf_matrix_clean)
cat("Dropped", rows_before - rows_after,
"rows with NA in", paste(env_no_soil, collapse = ", "), "\n")
############################################################################
# 5.  FILTER 2:  DROP LOCATIONS WITH < 6 REMAINING ROWS
############################################################################
loc_counts <- table(nmf_matrix_clean$Location)
keep_locations <- names(loc_counts[loc_counts>= 6])
nmf_matrix <- nmf_matrix_clean[nmf_matrix_clean$Location %in% keep_locations, ]
rows_after_loc <- nrow(nmf_matrix)
cat("Dropped", rows_after - rows_after_loc,
"rows from Locations with < 6 rows;",
"Final rows left:", rows_after_loc, "\n")
# Double check if there are any NA values in nmf matrix
anyNA(nmf_matrix)
set.seed(2025)
train <- createDataPartition(nmf_matrix$Yield, p = 0.8, list = FALSE)
train_df <- nmf_matrix[train, ]
test_df <- nmf_matrix[-train, ]
# NMF input matrices (7 features, no SoilRank), rows = features, cols = samples
X_train <- as.matrix(train_df[, env_no_soil])
X_test  <- as.matrix(test_df [, env_no_soil])
# create list of k values to find ideal value
k_list <- 2:7
rss_list <- numeric(length(k_list))
set.seed(2025)
for (i in seq_along(k_list)) {
k <- k_list[i]
fit <- nmf(X_train,
rank = k,
nrun = 10,
.options = "N")
rss_list[i] <- residuals(fit)
}
install.packages("NMF")
