################## 0. PACKAGES ############################

install.packages("BiocManager")
BiocManager::install("Biobase")

install.packages("NMF")
install.packages("caret")
install.packages("inflection")
install.packages("nnls")

library(nnls)
library(NMF)        # for nmf()
library(caret)      # for train/test split + RMSE
library(inflection) # for uik()




####################### 1. LOAD DATA ##########################
new_df <- as.data.frame(read.delim("./Data/OSACC Data Registered Varieties 1996-2021 with variety names.txt", header = T))


############################ 2. SOIL TYPE --> SoilRank ###########

# Check names of columns
colnames(new_df)

# Check all of the soil types that exists in the dataset
unique(new_df$Soil.Type)

# Lower case and trim white spaces of soil types 
new_df$Soil.Type <- tolower(trimws(new_df$Soil.Type))

# Check cleaned up soil types
unique(new_df$Soil.Type)

# Create Soil Rank
soil_Rank <- c(
  "loam"      = 1.0,
  "silt loam" = 0.8,
  "clay loam" = 0.6,
  "clay"      = 0.4,
  "sand"      = 0.2
)

# Add the soil rank column to the df
new_df$SoilRank <- soil_Rank[new_df$Soil.Type]

# Impute with median of soil ranks listed above
median_soil <- median(soil_Rank)
new_df$SoilRank[is.na(new_df$SoilRank)] <- median_soil

# Check if all NA values were assigned a number
sum(is.na(new_df$SoilRank))


############ 3.  MIN–MAX SCALE NUMERIC ENVIRONMENT COLUMNS ############

# Create a list with names of the features
env_cols <- c("SoilRank", "HUZ", "DTM",
                "Lodging", "Height", "SeedWt",
                "Protein", "Oil")

# Create a new data frame to store the scaled matrix
scaled_df <- new_df

# Scale the matrix using min-max normalization
for (cols in env_cols) {
  min_val <- min(scaled_df[[cols]], na.rm = T)
  max_val <- max(scaled_df[[cols]], na.rm = T)
  scaled_df[[cols]] <- (scaled_df[[cols]] - min_val)/(max_val - min_val)
}



####### 4.  FILTER 1:  DROP ROWS WITH ANY NA IN THE 7 NMF FEATURES ##########

# Remove soilRank from matrix
env_no_soil <- setdiff(env_cols, "SoilRank")
# rows before dropping NA values
rows_before <- nrow(scaled_df)
# Keep rows that have no NA values in any column
keep_rows <- complete.cases(scaled_df[, env_no_soil])
nmf_matrix_clean <- scaled_df[keep_rows, ]
# Check the number of rows after cleaning
rows_after <- nrow(nmf_matrix_clean)
cat("Dropped", rows_before - rows_after,
    "rows with NA in", paste(env_no_soil, collapse = ", "), "\n")



################ 5.  FILTER 2:  DROP LOCATIONS WITH < 6 REMAINING ROWS ############

loc_counts <- table(nmf_matrix_clean$Location)
keep_locations <- names(loc_counts[loc_counts>= 6])
nmf_matrix <- nmf_matrix_clean[nmf_matrix_clean$Location %in% keep_locations, ]
rows_after_loc <- nrow(nmf_matrix)


cat("Dropped", rows_after - rows_after_loc,
    "rows from Locations with < 6 rows;",
    "Final rows left:", rows_after_loc, "\n")

nmf_matrix$Variety.Name <- factor(nmf_matrix$Variety.Name)


########## 6.  TRAIN / TEST SPLIT (80/20) ###############

# Double check if there are any NA values in nmf matrix
anyNA(nmf_matrix)

set.seed(2025)
train <- createDataPartition(nmf_matrix$Yield, p = 0.8, list = FALSE)

train_df <- nmf_matrix[train, ]
test_df <- nmf_matrix[-train, ]

# NMF input matrices (7 features, no SoilRank), rows = features, cols = samples
X_train <- as.matrix(train_df[, env_no_soil])
X_test  <- as.matrix(test_df[, env_no_soil])

dim(X_train)
dim(X_test)


########## 7.  GET BEST RANK K USING UIK ###############################

# create list of k values to find ideal value
k_list <- 2:7
rss_list <- numeric(length(k_list))

set.seed(2025)

for (i in seq_along(k_list)) {
  k <- k_list[i]
  fit <- nmf(X_train,
             rank = k, 
             nrun = 10,
             .options = "N")
  rss_list[i] <- residuals(fit)
}

best_k <- uik(k_list, rss_list)[1]

# Plot of the inflection point
plot(k_list, rss_list, type = "b")
abline(v = best_k, col = "red", lty = 2)
cat("UIK suggests k = ", best_k, "\n")



######## 8.   FINAL NMF FIT (TRAIN) & PROJECT (TEST) USING BEST K #############

set.seed(2025)
nmf_final <- nmf(X_train,
                 rank = best_k,
                 nrun = 50,
                 .options = "N")
w_train <- basis(nmf_final)
colnames(w_train) <- paste0("Factor", seq_len(ncol(w_train)))

H <- coef(nmf_final)

# Project Test rows into same factors


w_test <- t(apply(X_test, 1, function(x) nnls(t(H), x)$x))

colnames(w_test) <- colnames(w_train)



############## 9A.  DATA FOR NMF + LM ############################

df_nmf_train <- data.frame(
  Yield = train_df$Yield,
  soilRank = train_df$SoilRank,
  w_train
)

df_nmf_test <- data.frame(
  Yield = test_df$Yield,
  soilRank = test_df$SoilRank,
  w_test
)

lm_nmf <- lm(
  formula = paste("Yield ~ soilRank +", paste(colnames(w_train), collapse = " + ")),
  data = df_nmf_train
  )


################# 9B.  DATA FOR EI × Variety #############################

lm_env <- lm(formula = paste("Yield ~", paste(env_cols, collapse = " + ")), data = train_df)


train_df$EI <- predict(lm_env, newdata = train_df)
test_df$EI <- predict(lm_env, newdata = test_df)

lm_EI <- lm(Yield ~ EI*Variety.Name, data = train_df)



######## 10.  PREDICT ON TEST SET & COMPARE RMSE ########################

# NMF predictions
pred_nmf <- predict(lm_nmf, newdata = df_nmf_test)
rmse_nmf <- RMSE(pred_nmf, df_nmf_test$Yield)

# EI LM predictions
pred_EI <- predict(lm_EI, newdata = test_df)
rmse_EI <- RMSE(pred_EI, test_df$Yield)

cat("\nOut-of-sample RMSEs",
    "\n  NMF + LM :", round(rmse_nmf, 3),
    "\n  EI × Var :", round(rmse_EI,  3), "\n")



